# Простое процессорное ядро

## Оглавление

- [Простое процессорное ядро](#простое-процессорное-ядро)
  - [Оглавление](#оглавление)
  - [Описание проекта](#описание-проекта)
  - [Структура проекта](#структура-проекта)
  - [Архитектура процессора](#архитектура-процессора)
    - [Основные компоненты](#основные-компоненты)
  - [Система команд](#система-команд)
  - [Пример программы](#пример-программы)
    - [Ассемблероподобный код](#ассемблероподобный-код)
    - [Перевод в бинарный формат (`program.mem`)](#перевод-в-бинарный-формат-programmem)
    - [Сортировка вставками](#сортировка-вставками)
  - [Тестирование](#тестирование)
  - [InstrToBinTranslator — инструментарий: транслятор и отладчик](#instrtobintranslator--инструментарий-транслятор-и-отладчик)

## Описание проекта

Данный проект представляет собой реализацию **простого процессорного ядра последовательного типа** на языке **Verilog**, а также инструментарий на **Python** для перевода ассемблероподобных инструкций в бинарный формат, выполняемый данным процессором.

Архитектура процессора построена по принципам **гарвардской архитектуры** — раздельная память для команд и данных, что позволяет повысить эффективность и предсказуемость выполнения.

## Структура проекта

```
.
├── Cpu - Реализация процессорного ядра на Verilog
└── InstrToBinTranslator - Инструменты для создания программы и отладки
```

## Архитектура процессора

Процессор реализует простую **пятистадийную модель выполнения команд**:

1. **Fetch** — загрузка команды в регистр текущей команды
2. **Decode / Operand Fetch** — извлечение операндов из памяти или регистров
3. **Execute** — выполнение операции
4. **Memory / Writeback** — запись результата в память или регистр
5. **PC Update** — переход к следующей команде или изменённый адрес при `JMP` / `JUMP_LESS`

### Основные компоненты

- `cmd_mem` — память команд (1024 ячейки по 24 бита)
- `mem` — память данных (1024 ячейки по 10 бит)
- `RF` — регистровый файл (16 регистров по 10 бит)
- `pc` — счётчик команд
- `stage_counter` — стадия выполнения
- `op1`, `op2`, `res` — внутренние операнды и результат операции

## Система команд

| Команда     | Описание                                                                 | Формат                                | Псевдокод                                      |
| ----------- | ------------------------------------------------------------------------ | ------------------------------------- | ---------------------------------------------- |
| `NOP`       | Ничего не делать                                                         | [OpCode]                              | void do(){}                                    |
| `LTM`       | Загрузить литерал в память                                               | [OpCode][literal][adr_m]              | mem[adr_m] = literal                           |
| `MTR`       | Загрузить значение из памяти в регистр                                   | [OpCode][adr_r1][adr_m1]              | RF[adr_r1] = mem[adr_m1]                       |
| `RTR`       | Загрузить значение из регистра в регистр                                 | [OpCode][adr_r1][adr_r2]              | RF[adr_r1] = RF[adr_r2]                        |
| `SUB`       | Вычитание                                                                | [OpCode][adr_r1][adr_r2][adr_r3]      | RF[adr_r3] = RF[adr_r1] - RF[adr_r2]           |
| `SUM`       | Сложение                                                                 | [OpCode][adr_r1][adr_r2][adr_r3]      | RF[adr_r3] = RF[adr_r1] + RF[adr_r2]           |
| `JMP`       | Безусловный переход                                                      | [OpCode][adr_to_jump]                 | pc = adr_to_jump                               |
| `JUMP_LESS` | Условный переход                                                         | [OpCode][adr_r1][adr_r2][adr_to_jump] | if (RF[adr_r1] >= RF[adr_r2]) pc = adr_to_jump |
| `MTRK`      | Загрузить регистр из памяти по адресу, хранящемуся в регистре            | [OpCode][adr_r1][adr_r2]              | RF[adr_r1] = mem[RF[adr_r2]]                   |
| `RTMK`      | Записать значение из регистра в память по адресу, хранящемуся в регистре | [OpCode][adr_r1][adr_r2]              | mem[RF[adr_r1]] = RF[adr_r2]                   |

## Пример программы

### Ассемблероподобный код

```
LTM 5 0
LTM 7 1
LTM 4 2
...
NOP
```

### Перевод в бинарный формат (`program.mem`)

```
000100000001010000000000
000100000001110000000001
...
000000000000000000000000
```

### Сортировка вставками

Бинарный файл с сортировкой вставками находится в

- [`Cpu/CPU.srcs/sources_1/new/program.mem`](./Cpu/CPU.srcs/sources_1/new/program.mem)

Не отсортированный массив, последнее число - количество элементов

![Не отсортированный массив](./imgs/unsorted_array.png)

Отсортированный массив, последнее число - количество элементов

![Отсортированный массив](./imgs/sorted_array.png)

## Тестирование

Файл `TestCPU.v` реализует тестовую среду, создающую тактовый сигнал и завершающую симуляцию при достижении конца программы.

## InstrToBinTranslator — инструментарий: транслятор и отладчик

Папка InstrToBinTranslator содержит набор Python‑утилит для подготовки, трансляции и отладки программ под CPU.

Основные возможности:

- разбор ассемблероподобных файлов;
- генерация бинарного образа (program.mem);
- пошаговая симуляция выполнения инструкций;
- логирование состояния регистров и памяти для отладки.

Подробная документация и примеры использования доступны в:

- [`InstrToBinTranslator/README.md`](./InstrToBinTranslator/README.md)
